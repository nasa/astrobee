%
%    This file was auto-generated by ACADO Toolkit.
%
%    ACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.
%    Copyright (C) 2008-2011 by Boris Houska, Hans Joachim Ferreau et al., K.U.Leuven.
%    Developed within the Optimization in Engineering Center (OPTEC) under
%    supervision of Moritz Diehl. All rights reserved.
%


clear stages params outputs codeoptions

%% Generator for a FORCES QP solver used by the ACADO OCP solver

%
% User options
%

% Number of states
nx = 21;
% Number of controls
nu = 3;
% Number of discretization (shooting) nodes
N  = 11;

% Lower and upper bounds on stage variables, for all N stages
lbIdx = { ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20, 22, 23, 24}, ...
	{2, 5, 8, 20} ...
};
ubIdx = { ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{22, 23, 24}, ...
	{} ...
};
	
% Constant Hessian
constHessian = 1;
% Fixed initial state
fixedInitialState = 1;

%% Define FORCES multistage problem

stages = MultistageProblem( N );

for i = 1: N
    if (i == 1)
		
		%
		% Initial stage
		%
        
        % Dimension
        stages(i).dims.n = nx + nu;					% number of stage variables
		
		if (fixedInitialState == 1)
			stages(i).dims.r = 2 * nx;				% number of equality constraints        
		else
			stages(i).dims.r = nx;			
		end;
		
        stages(i).dims.l = length( lbIdx{ i } );	% number of lower bounds
        stages(i).dims.u = length( ubIdx{ i } );	% number of upper bounds
        stages(i).dims.p = 0;						% number of polytopic constraints
        stages(i).dims.q = 0;						% number of quadratic constraints
        
        % Cost
		if (constHessian == 1)
			params( 1 ) = newParam('H1', 1: 1: N - 1, 'cost.H');
		else
			params( 1 ) = newParam('H1', 1, 'cost.H');
		end;
		params(end + 1) = newParam('f1', 1, 'cost.f');
        
        % Lower bounds
        stages(i).ineq.b.lbidx = cell2mat( lbIdx{ i } );
		if (~isempty( lbIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'lb', i), i, 'ineq.b.lb');
		end;
		
        % Upper bounds
        stages(i).ineq.b.ubidx = cell2mat( ubIdx{ i } );
		if (~isempty( ubIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'ub', i), i, 'ineq.b.ub');
		end;
        
        % equality constraints
		params(end + 1) = newParam('C1', 1, 'eq.C');
		params(end + 1) = newParam('d1', 1, 'eq.c');
        
	elseif (i < N)
		
		%
		% Stages along horizon
		%
        
        % Dimension
        stages(i).dims.n = nx + nu;					% number of stage variables
        stages(i).dims.r = nx;						% number of equality constraints        
        stages(i).dims.l = length( lbIdx{ i } );	% number of lower bounds
        stages(i).dims.u = length( ubIdx{ i } );	% number of upper bounds
        stages(i).dims.p = 0;						% number of polytopic constraints
        stages(i).dims.q = 0;						% number of quadratic constraints
        
        % Cost
		if (constHessian == 0)
			params(end + 1) = newParam(sprintf('%s%d', 'H', i), i, 'cost.H');
		end;
		params(end + 1) = newParam(sprintf('%s%d', 'f', i), i, 'cost.f');
		
		% Lower bounds
        stages(i).ineq.b.lbidx = cell2mat( lbIdx{ i } );
		if (~isempty( lbIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'lb', i), i, 'ineq.b.lb');
		end;
		
        % Upper bounds
        stages(i).ineq.b.ubidx = cell2mat( ubIdx{ i } );
		if (~isempty( ubIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'ub', i), i, 'ineq.b.ub');
		end;
        
        % Equality constraints		
		params(end + 1) = newParam(sprintf('%s%d', 'C', i), i, 'eq.C');
		params(end + 1) = newParam(sprintf('%s%d', 'd', i), i, 'eq.c');
		
        if(i == 2 && fixedInitialState == 1)
			stages(i).eq.D = [zeros(nx, nx + nu); -eye(nx), zeros(nx, nu)];
        else
            stages(i).eq.D = [-eye( nx ), zeros(nx, nu)];
		end;
        
	else
		
		%
		% Final stage
		%
        
        % Dimension
        stages(i).dims.n = nx;						% number of stage variables
        stages(i).dims.r = 0;						% number of equality constraints        
        stages(i).dims.l = length( lbIdx{ i } );    % number of lower bounds
        stages(i).dims.u = length( ubIdx{ i } );    % number of upper bounds
        stages(i).dims.p = 0;						% number of polytopic constraints
        stages(i).dims.q = 0;						% number of quadratic constraints
        
        % Cost		
		params(end + 1) = newParam(sprintf('%s%d', 'H', i), i, 'cost.H');
		params(end + 1) = newParam(sprintf('%s%d', 'f', i), i, 'cost.f');
        
        % Lower bounds
        stages(i).ineq.b.lbidx = cell2mat( lbIdx{ i } );
		if (~isempty( lbIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'lb', i), i, 'ineq.b.lb');
		end;
		
        % Upper bounds
        stages(i).ineq.b.ubidx = cell2mat( ubIdx{ i } );
		if (~isempty( ubIdx{ i } ))
			params(end + 1) = newParam(sprintf('%s%d', 'ub', i), i, 'ineq.b.ub');
		end;
        
        % Equality constraints        
        stages(i).eq.D = -eye(nx);
        
	end;
end;

%% Define outputs of the solver
for i = 1: N
	outputs( i ) = newOutput(sprintf('%s%d', 'out', i), i, 1: 1: stages(i).dims.n);
end;

%% Solver settings
codeoptions = getOptions('forces');

codeoptions.printlevel	= 0;
codeoptions.maxit		= 783;


%% Generate code
generateCode(stages, params, codeoptions, outputs);
