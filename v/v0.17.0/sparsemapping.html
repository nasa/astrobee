<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NASA Astrobee Robot Software: Sparse mapping</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.png" type="image/png" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="freeflyer.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td id="projectlogo"><img alt="Logo" src="astrobee-logo.png" height="100"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NASA Astrobee Robot Software
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
   <div id="projectbrief">Flight software for the Astrobee robots operating inside the International Space Station.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sparsemapping.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Sparse mapping </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md402"></a>
Creation of sparse maps for robot localization</h1>
<h2><a class="anchor" id="autotoc_md403"></a>
What is a map</h2>
<p>A map consists of feature descriptors and associated 3D positions of the features. A map may also contain a vocabulary database which enables fast lookup of similar images.</p>
<h2><a class="anchor" id="autotoc_md404"></a>
Map files</h2>
<p>Maps are stored as protobuf files.</p>
<h2><a class="anchor" id="autotoc_md405"></a>
ROS node</h2>
<p>The ROS node takes images and a map as input, and outputs visual features detected in the image and their 3D coordinates.</p>
<h3><a class="anchor" id="autotoc_md406"></a>
Inputs</h3>
<ul>
<li><code>/hw/cam_nav</code>: Camera images The map file. See the <a class="el" href="map_building.html">Map building</a> section (towards the bottom) for its assumed location on the robot.</li>
</ul>
<h3><a class="anchor" id="autotoc_md407"></a>
Outputs</h3>
<ul>
<li><code>/localization/mapped_landmarks/features</code></li>
<li><code>/localization/mapped_landmarks/registration</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md408"></a>
The environment</h2>
<p>It will be convenient in this document to set these environmental variables, pointing to the source and build directories. They may need to be adjusted given your setup. </p><pre class="fragment">export ASTROBEE_SOURCE_PATH=$HOME/astrobee/src
export ASTROBEE_BUILD_PATH=$HOME/astrobee
</pre><p>To access many of the localization tools, such as <code>build_map</code>, <code>merge_maps</code>, etc., without specifying a full path, also consider setting: </p><pre class="fragment">export PATH=$ASTROBEE_BUILD_PATH/devel/lib/sparse_mapping:$PATH
</pre><h2><a class="anchor" id="autotoc_md409"></a>
Tools and procedures</h2>
<h3><a class="anchor" id="autotoc_md410"></a>
Record a bag</h3>
<p>Record on the robot in order to not drop too many frames. Launch the camera node. Connect to the robot. Create a subdirectory in /data where the data will be recorded, as the home directory on the robot is too small. Move the robot slowly to make sure neighboring images have enough overlap, and to reduce motion blur. Run: </p><pre class="fragment">rosbag record /hw/cam_nav
</pre><p>The name of the topic containing the images may differ from /hw/cam_nav. To see what topics a bag file contains one can use the command </p><pre class="fragment">rosbag info bagfile.bag
</pre><h3><a class="anchor" id="autotoc_md411"></a>
Filter the bag</h3>
<p>Usually the bags are acquired at a very high frame rate, and they are huge. A preliminary filtering of the bag images while still on the robot can be done with the command: </p><pre class="fragment">rosbag filter input.bag output.bag                           \
  "(topic == '/hw/cam_nav') and (float(t.nsecs)/1e+9 &lt;= 0.1)"
</pre><p>Here, for every second of recorded data, we keep only the first tenth of a second. This number may need to be adjusted. Later, a further selection of the images can be done.</p>
<h3><a class="anchor" id="autotoc_md412"></a>
Copy the bag from the robot</h3>
<p>From the local machine, fetch the bag: </p><pre class="fragment">rsync -avzP astrobee@10.42.0.32:/data/bagfile.bag .
</pre><p>Here, the IP address of P4D was used, which may differ from your robot's IP address.</p>
<h3><a class="anchor" id="autotoc_md413"></a>
Merging bags</h3>
<p>The bags created on the ISS are likely split into many smaller bags, for easy and reliability of transfer. Those can be merged into one bag as follows: </p><pre class="fragment">$ASTROBEE_BUILD_PATH/devel/lib/localization_node/merge_bags \
  -output_bag &lt;output bag&gt; &lt;input bags&gt;
</pre><p>This tool can also save images only in a given time range, and filter out some images, for example, by keeping only one image per second.</p>
<p>See <a class="el" href="merge_bags.html">Merge bags</a> for the full documentation.</p>
<h3><a class="anchor" id="autotoc_md414"></a>
Extracting images</h3>
<p>To extract images from a bag file: </p><pre class="fragment">$ASTROBEE_BUILD_PATH/devel/lib/localization_node/extract_image_bag \
  &lt;bagfile.bag&gt; -use_timestamp_as_image_name                       \
  -image_topic /hw/cam_nav -output_directory &lt;output dir&gt;
</pre><p>The above assumes that the software was built with ROS on.</p>
<p>Please check using 'rosbag info' the nav cam topic in the bag, as its name can change.</p>
<h3><a class="anchor" id="autotoc_md415"></a>
Building a map</h3>
<p>The <code>build_map</code> tools is used to construct a map. See <a class="el" href="map_building.html">Map building</a> for further details.</p>
<p>See <a class="el" href="theia_map.html">Building a map with Theia</a> for how to build a map with the external Theia package and import it into Astrobee.</p>
<h3><a class="anchor" id="autotoc_md416"></a>
Visualization</h3>
<p>To visualize a map, or just a list of images, use the command: </p><pre class="fragment">nvm_visualize [ &lt;output.map&gt; ] [ &lt;image1.jpg&gt; &lt;image2.jpg&gt; ... ]
</pre><p>In the viewer, press <code>a</code> and <code>d</code> (or the left and right arrow keys, or the Ins and Del keys on the num pad) to navigate through the images. The current image being displayed will be echoed on the command line. Press <code>c</code> to show the cameras and triangulated points in 3D. Press <code>q</code> to exit the viewer. Press 'Home' and 'End' to go to first and last image.</p>
<p>In <code>c</code> mode, press left and right to visualize the localization results for the input image <code>imageN.jpg</code>. If no images are passed in, the arrow keys display each frame of the map.</p>
<p>Also, in the <code>c</code> mode, when points and cameras are shown in 3D, pressing <code>a</code> will save the current 3D pose to disk, while pressing <code>b</code> will read a 3D pose from disk and apply it. This way, when two viewers are open side by side, they can be made to show the results from the same perspective.</p>
<p>The viewer can display just a subset of the cameras, using the <code>-first</code> and <code>-last</code> options, and the size of cameras can be set with <code>-scale</code>.</p>
<p>Only the camera positions can be displayed, without the 3D points, if the viewer is invoked with <code>-skip_3d_points</code>. The cameras can be made to rotate around the center of mass of the cameras, rather than the origin, using the <code>d</code> key. When in 3D view, rendering of thumbnails of the images can be skipped, as that makes the viewer slow, with '-skip_3d_images'.</p>
<p>Clicking on an interest point with the middle mouse will display all images in which that interest point was detected, with the interest point in each of them shown as a red dot. Clicking back on the original window with the middle mouse will make these images go away.</p>
<p>Clicking with the left mouse button on an image will print its name and the pixel coordinates where the mouse hit. This can be useful in collecting a subset of the images. (After clicking, a bug in OpenCV disables the arrow keys, then one can navigate with the "Ins" and "Del" keys on the numpad.)</p>
<p>This tool can be invoked to look at just images, without any map being built. It can also delete images in this mode, with the 'x' key, if invoked as: </p><pre class="fragment">nvm_visualize -enable_image_deletion &lt;image dir&gt;/*jpg
</pre><h3><a class="anchor" id="autotoc_md417"></a>
Localize a single frame</h3>
<p>All the commands below assume that the environment was set up, as specified in the <a class="el" href="map_building.html">Map building</a> section.</p>
<p>To test localization of a single frame, use the command: </p><pre class="fragment">localize &lt;map.map&gt; &lt;image.jpg&gt; -histogram_equalization
</pre><p>If invoked with the option -verbose_localization, it will list the images most similar to the one being localized. To increase the number of similar images, use the -num_similar option. Another useful flag is &ndash;v 2 when it will print more verbose information. Most of the options of the localize_cams tool (see below) are also accepted.</p>
<h3><a class="anchor" id="autotoc_md418"></a>
Testing localization using two maps</h3>
<p>To test localization of many images, one can acquire two sets of images of the same indoor environment, and create two maps ready for localization. That is, maps are built, registered to the world coordinate system, rebuilt with BRISK, and then a vocabulary database is created. Name those maps reference and source.</p>
<p>For each image in the source map, one can localize it against the reference map, and compare its camera position and orientation after localization with the "known" position and orientation from the source map.</p>
<p>This is not a fool-proof test, since neither of the two maps contains measured ground truth, rather a simulated version of it, yet it can be useful, assuming that maps are individually accurate enough and well-registered.</p>
<p>This functionality is implemented in the localize_cams tool. Usage: </p><pre class="fragment">localize_cams -num_similar 20 -ransac_inlier_tolerance 5      \
  -num_ransac_iterations 200 -min_brisk_features 400          \
  -max_brisk_features 800 -min_brisk_threshold 20             \
  -default_brisk_threshold 90 -max_brisk_threshold 110        \
  -detection_retries 5 -num_threads 2                         \
  -early_break_landmarks 100 -histogram_equalization          \
  -reference_map ref.map -source_map source.map
</pre><p>Here we use values that are different from </p><pre class="fragment">$ASTROBEE_SOURCE_PATH/astrobee/config/localization.config 
</pre><p>which are used for localization on the robot, since those are optimized for speed and here we want more accuracy.</p>
<h3><a class="anchor" id="autotoc_md419"></a>
Testing localization using a bag</h3>
<p>See the ekfbag page for how to study how well a BRISK map with a vocabulary database does when localizing images from a bag.</p>
<h3><a class="anchor" id="autotoc_md420"></a>
Extract sub-maps</h3>
<p>The tool <code>extract_submap</code> can be used to extract a submap from a map, containing only a specified list of images, or a given range of image indices, or images with camera center in a given box. Usage: </p><pre class="fragment">extract_submap -input_map &lt;input map&gt; -output_map &lt;output map&gt; \
  &lt;images to keep&gt;
</pre><p>or extract_submap -input_map &lt;input map&gt; -output_map &lt;output map&gt; \ -image_list &lt;file&gt; or extract_submap -input_map &lt;input map&gt; -output_map &lt;output map&gt; \ -exclude &lt;images to exclude&gt;</p>
<p>or </p><pre class="fragment">extract_submap -input_map &lt;input map&gt; -output_map &lt;output map&gt; \
  -cid_range "min_cid max_cid"
</pre><p>(here first image has cid = 0, and the range is inclusive at both ends), or </p><pre class="fragment">extract_submap -input_map &lt;input map&gt; -output_map &lt;output map&gt; \
  -xyz_box "xmin xmax ymin ymax zmin zmax"
</pre><p>If it is desired to not re-adjust the cameras after the submap is extracted (for example, if the map is already registered), use the <code>-skip_bundle_adjustment</code> option.</p>
<p>If the input map has a vocabulary database of features, it will need to be rebuilt for the extracted submap using </p><pre class="fragment">build_map -vocab_db
</pre><h3><a class="anchor" id="autotoc_md421"></a>
Merge maps</h3>
<h4><a class="anchor" id="autotoc_md422"></a>
General usage</h4>
<p>Given a set of SURF maps, they can be merged using the command: </p><pre class="fragment">merge_maps &lt;input maps&gt; -output_map merged.map \
  -num_image_overlaps_at_endpoints 50
</pre><p>It is very important to note that only maps with SURF features (see <a class="el" href="map_building.html">Map building</a>) can be merged. If a map has BRISK features, it needs to be rebuilt with SURF features, as follows: </p><pre class="fragment">  build_map -rebuild -histogram_equalization       \
    -rebuild_detector SURF -output_map &lt;output map&gt;
</pre><p>and then these regenerated maps can be merged.</p>
<p>Merging is more likely to succeed if the images at the endpoints of one map are similar to images at the endpoints of the second map, and in particular, if some of the same images show up at the endpoints of both maps. A larger value of <code>-num_image_overlaps_at_endpoints</code> may result in higher success but will take more time.</p>
<h4><a class="anchor" id="autotoc_md423"></a>
Registration and bundle adjustment</h4>
<p>The input maps to be merged need not be registered, but that may help improve the success of merging. Also, it may be preferable that the images at the beginning and end of the maps to merge be close to points used in registration. The implication here is that the more geometrically correct the input maps are, and the more similar to each other, the more likely merging will succeed.</p>
<p>Registration to the real-world coordinate system must be (re-)done after the maps are merged, as the bundle adjustment done during merging may move things somewhat.</p>
<p>After a merged map is created and registered, it can be rebuilt with the BRISK detector to be used on the robot.</p>
<p>When manipulating many submaps, it is suggested that bundle adjustment be skipped during merging, using the </p><pre class="fragment">-skip_bundle_adjustment
</pre><p>option until the final map is computed, as this step can be time-consuming. Bundle adjustment must happen however eventually, before any map registration and rebuilding.</p>
<h4><a class="anchor" id="autotoc_md424"></a>
Keeping first map fixed</h4>
<p>If there are only two maps to merge, and the first of the two maps to merge is already registered, it may be desirable to keep that portion fixed during merging when bundle adjustment happens, to avoid redoing the registration, and perhaps to keep consistency with other work already done, such as a dense map product.</p>
<p>Then, use the flag <code>-fix_first_map</code> when merging the maps. In this case, if an image shows in both maps, then, once the maps are merged, the camera poses of the shared images will be replaced with the ones from the first map, before reoptimizing the remaining camera poses from the second map.</p>
<h3><a class="anchor" id="autotoc_md425"></a>
How to build a map efficiently</h3>
<p>Often times map-building can take a long time, or it can fail. A cautious way of building a map is to build it in portions (perhaps on different machines), examine them, and merge them with <code>merge_maps</code>.</p>
<p>If map-building failed, parts of it could still be salvageable (one can use nvm_visualize for inspection). Valid submaps can be extracted with <code>extract_submap</code>. Then those can be merged with <code>merge_maps</code>.</p>
<p>When two maps to be merged overlap only in the middle, and they are both large, the number -num_image_overlaps_at_endpoints will need to be large which would make merging very slow. A very useful option can then be the flag <code>-fast_merge</code> for this tool. It won't create matches among the two maps, but will instead identify the shared images among the two maps thus merging the maps, if shared images exist.</p>
<p>If no such images are available, but the two maps do see the same physical location in some portions (if from different views), each of the two maps can be first merged with the same small map of that shared location, and then the newly merged map which now will have shared images can be merged with the <code>-fast_merge</code> flags.</p>
<p>The <code>-fast_merge</code> option assumes that a decent number of images are shared among the maps, and that those cover a reasonably large and representative portion of the desired environment, otherwise it may not give accurate results. In either case, bundle adjustment must be applied after the merge operations are done and before registration, which can be done either with <code>merge_maps</code> or <code>build_map</code>.</p>
<p>To summarize, with careful map surgery (extract submaps and merge submaps) large maps can be made from smaller or damaged ones within reasonable time.</p>
<p>All these operations should be applied on maps with SURF features. Hence, the general approach for building large maps is to create small SURF maps using the command: </p><pre class="fragment">build_map -feature_detection -feature_matching -track_building    \
 -incremental_ba -bundle_adjustment                               \
 -histogram_equalization -num_subsequent_images 100               \
 images/*jpg -output_map &lt;map file&gt;
</pre><p>Then, examine the maps individually, merge them as appropriate, and perform bundle adjustment and registration as per the <a class="el" href="map_building.html">Map building</a> section. Only when a good enough map is obtained, a renamed copy of it should be rebuilt with BRISK features and a vocabulary database to be used on the robot.</p>
<h3><a class="anchor" id="autotoc_md426"></a>
Map strategy for the space station</h3>
<p>For the space station, there exists one large SURF map with many images, and a small BRISK map with fewer images. If new images are acquired, it is suggested several small maps be assembled from them, and those be merged to the large SURF map.</p>
<p>The key idea here is to add some well-chosen subsequences of those new images to the SURF map, but only a few, for which localization failed, to the BRISK map. This is best illustrated by an example.</p>
<p>Say the large original SURF map had 2000 images, and the smaller BRISK map had only 1400 images. Say 300 new images have been acquired, and for 80 of them localization failed. So, things will change as follows:</p>
<ul>
<li>SURF map goes from 2000 to 2000 + 300 = 2300 images</li>
<li>BRISK map goes from 1400 to 1400 + 80 = 1480 images</li>
</ul>
<p>The precise details are described in the next section.</p>
<h3><a class="anchor" id="autotoc_md427"></a>
Growing a map when more images are acquired</h3>
<p>Sometimes things in the desired environment change enough, or the lighting changes, and an existing map may no longer do as well in some areas. Then, new images should be added to the map. The tool grow_map.py can help with that.</p>
<p>First, out of the new images a set must be selected from which to build a new map. We assume that the images in that set are further broken up into several subsets, with each image in a subset overlapping with the next one in that subset. For example, there can exist a subset for the ceiling, one for the walls, etc.</p>
<p>A SURF map can be built for each subset, and those can be merged. (A very useful option here can be -fast_merge.) Then, the new merged SURF map can be merged with the earlier SURF map, and the combined map can be bundle-adjusted and registered. While such a SURF map will be very reliable, it will contain redundant information, so we will outline below how to create a BRISK map that starts the same as the BRISK map that existed before that, with only a minimum of images added for which localization now fails. The new large SURF map will be used as the source of the camera poses for the updated BRISK map, but the latter will have fewer images.</p>
<p>We need some notation. Let prev_brisk_vocab_hist.map be the previous BRISK map, before new images are added, prev_surf_registered.map be the previous registered SURF map (that can have more images than prev_brisk_vocab_hist.map). Let curr_surf_registered.map be the large SURF map that is obtained from prev_surf_registered.map merged with the images acquired this time, and curr_brisk_no_prune_hist.map be obtained from curr_surf_registered.map using the -rebuild and -histogram_equalization options. The prev_brisk_vocab_hist.map will already be pruned and have a vocabulary database, but curr_brisk_no_prune_hist.map is assumed to have none of these. Not being pruned is very important. And again, all these maps must be registered.</p>
<p>Let also list1.txt, ..., listN.txt contain the images for those subsets of new images mentioned earlier, such as list_wall.txt, list_floor.txt, etc., with the order of images in this list be the same as in the submap for the subset made from that list (which is the same order as output by build_map -info). We will create a new BRISK map, named curr_brisk_vocab_hist.map, that will be pruned and with a vocabulary database (so ready to be used, just like prev_brisk_vocab_hist.map) that will have only some of the new images as follows:</p>
<ul>
<li>Start with prev_brisk_vocab_hist.map</li>
<li>Add all new images in list1.txt for which localization failed against prev_brisk_vocab_hist.map, thus getting a map named curr1.map.</li>
<li>Add all new images in list2.txt for which localization against curr1.map failed.</li>
<li>Etc.</li>
</ul>
<p>The logic here is very simple. Don't add all new images at once. Add them in batches, and for each batch remember the fact that the previous batch already made the map better, so don't add images from a batch if they are not strictly necessary.</p>
<p>The following Python code implements this: </p><pre class="fragment">python astrobee/src/localization/sparse_mapping/tools/grow_map.py \
  -histogram_equalization -small_map prev_brisk_vocab_hist.map    \
  -big_map curr_brisk_no_prune_hist.map -work_dir work            \
  -output_map curr_brisk_vocab_hist.map                           \
  list1.txt list2.txt ... listN.txt
</pre><p>After this is finished, the work directory can be wiped.</p>
<p>It is very important to never remove like this images from the SURF map. This can result in this map breaking into disconnected sets when being bundle adjusted. If desired to make the SURF map smaller, one should examine the submaps it is made of (typically each submap has its images in a subdirectory), and then one should carefully study which submap (or portions of it) are not necessary for the whole map's cohesiveness.</p>
<p>Also note that the grow_map.py script takes a lot of other parameters on input that must be the same as in localization.config.</p>
<h3><a class="anchor" id="autotoc_md428"></a>
Reducing the number of images in a map</h3>
<p>Sometimes a map has too many similar images. The tool reduce_map.py attempts to reduce their number without sacrificing the map quality.</p>
<p>To use this feature, it is very important that the input map is not pruned. This map should be made of of BRISK features and registered. It need not have a vocab db.</p>
<p>Usage: </p><pre class="fragment">python astrobee/src/localization/sparse_mapping/tools/reduce_map.py \
  -input_map &lt;input map&gt; -min_brisk_threshold &lt;val&gt;                 \
  -default_brisk_threshold &lt;val&gt; -max_brisk_threshold &lt;val&gt;         \
  -localization_error &lt;val&gt; -work_dir &lt;work dir&gt;                    \
  -sample_rate &lt;val&gt; -histogram_equalization
</pre><p>The BRISK thresholds here must be as when the map was built (ideally like in localization.config). The -histogram_equalization flag is necessary if your map was built with it.</p>
<p>A sequence of ever-smaller output maps are saved in the work directory. They are pruned maps, with a vocabulary database, unlike the input unpruned map.</p>
<p>The algorithm is as follows. Randomly remove a fraction (stored in -sample_rate, typically 1/4th) of images form a map. Localize the images from the full map against the images of the reduced map. Images for which localization fails with more than a given error (typically 2 cm) are added back to the reduced map. This is repeated until no more images need adding.</p>
<p>The reduced map is written to </p><pre class="fragment">&lt;work_dir&gt;/submap_iter0.map
</pre><p>Then more images are taken out of the map and all the previous process is repeated (this is called the outer iteration), each time obtaining a smaller map named </p><pre class="fragment">&lt;work_dir&gt;/submap_iter&lt;outer iter&gt;.map
</pre><p>One should carefully evaluate these output maps. Likely after a couple of attempts the quality of the map may start degrading. To use more attempts, set the value of the -attempts variable.</p>
<p>Instead of taking images out of the map randomly, one can start with a reduced map with a small list of desired images which can be set with -image_list, and then all images for which localization fails will be added back to it.</p>
<p><a class="el" href="build_map_from_multiple_bags.html">Build map from multiple bags</a> <a class="el" href="map_building.html">Map building</a> <a class="el" href="total_station.html">Total Station</a> <a class="el" href="granite_lab_registration.html">Granite Lab Registration</a> <a class="el" href="faro.html">Faro</a> <a class="el" href="theia_map.html">Building a map with Theia</a> <a class="el" href="import_map.html">Importing a map in .nvm format</a> <a class="el" href="export_map.html">Exporting a map to the .nvm format</a> <a class="el" href="merge_bags.html">Merge bags</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<script type="text/javascript" src="/astrobee/doc_version_select.js"></script>
</body>
</html>
